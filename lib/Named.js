// Generated by CoffeeScript 1.10.0
(function() {
  var Named, Scope, SurfaceUtil,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  SurfaceUtil = require("ikagaka.shell.js").SurfaceUtil;

  Scope = require("./Scope").Scope;

  Named = (function(superClass) {
    extend(Named, superClass);

    function Named(namedId, shell, balloon, nmdmgr) {
      this.namedId = namedId;
      this.shell = shell;
      this.balloon = balloon;
      this.nmdmgr = nmdmgr;
      Named.__super__.constructor.call(this);
      this.element = document.createElement("div");
      this.scopes = [];
      this.currentScope = null;
      this.destructors = [];
      this.initDOMStructure();
      this.initEventListener();
      this.scope(0).surface(0);
      this.scope(1).surface(10);
      Promise.resolve(this);
    }

    Named.prototype.initDOMStructure = function() {
      this.$named = $(this.element).addClass("named");
    };

    Named.prototype.initEventListener = function() {
      var $target, relLeft, relTop;
      $target = null;
      relLeft = relTop = 0;
      this.shell.on("mouse", (function(_this) {
        return function(ev) {
          var $scope, $surfaceCanvas, clientX, clientY, left, pageX, pageY, ref, ref1, ref2, top;
          if (ev.transparency === true && ev.type !== "mousemove") {
            SurfaceUtil.recursiveElementFromPoint(ev.event, _this.nmdmgr.element, ev.event.target);
            return;
          }
          switch (ev.type) {
            case "mouseup":
              $target = null;
              break;
            case "mousemove":
              if ($target != null) {
                $surfaceCanvas = $(_this.scopes[ev.scopeId].element).find(".surfaceCanvas");
                ref = SurfaceUtil.getEventPosition(ev.event), pageX = ref.pageX, pageY = ref.pageY, clientX = ref.clientX, clientY = ref.clientY;
                $target.css({
                  right: document.body.clientWidth - clientX - ($surfaceCanvas.width() - relLeft),
                  bottom: document.body.clientHeight - clientY - ($surfaceCanvas.height() - relTop)
                });
              }
              break;
            case "mousedown":
              $target = $scope = $(_this.scopes[ev.scopeId].element);
              ref1 = $target.offset(), top = ref1.top, left = ref1.left;
              ref2 = SurfaceUtil.getEventPosition(ev.event), pageX = ref2.pageX, pageY = ref2.pageY, clientX = ref2.clientX, clientY = ref2.clientY;
              relLeft = clientX - (left - window.scrollX);
              relTop = clientY - (top - window.scrollY);
              _this.$named.append($scope);
              _this.$named.appendTo(_this.nmdmgr.element);
          }
          _this.emit("mouseShell", ev);
        };
      })(this));
      this.balloon.on("mouse", (function(_this) {
        return function(ev) {
          var $scope, clientX, clientY, left, offsetX, offsetY, pageX, pageY, ref, ref1, ref2, screenX, screenY, top;
          $scope = $(_this.scopes[ev.scopeId].element);
          switch (ev.type) {
            case "mouseup":
              $target = null;
              break;
            case "mousemove":
              if ($target != null) {
                ref = SurfaceUtil.getEventPosition(ev.event), pageX = ref.pageX, pageY = ref.pageY, clientX = ref.clientX, clientY = ref.clientY, screenX = ref.screenX, screenY = ref.screenY;
                $scope = $(_this.scopes[ev.scopeId].element);
                if (pageX - relLeft + $scope.width() / 2 > 0) {
                  _this.scope(ev.scopeId).blimp().right();
                } else {
                  _this.scope(ev.scopeId).blimp().left();
                }
                $target.css({
                  left: pageX - relLeft,
                  top: pageY - relTop
                });
              }
              break;
            case "mousedown":
              $scope = $(_this.scopes[ev.scopeId].element);
              $target = $scope.find(".blimp");
              ref1 = $target.offset(), top = ref1.top, left = ref1.left;
              offsetY = parseInt($target.css("left"), 10);
              offsetX = parseInt($target.css("top"), 10);
              ref2 = SurfaceUtil.getEventPosition(ev.event), pageX = ref2.pageX, pageY = ref2.pageY, clientX = ref2.clientX, clientY = ref2.clientY, screenX = ref2.screenX, screenY = ref2.screenY;
              relLeft = pageX - offsetY;
              relTop = pageY - offsetX;
              _this.$named.append($scope);
              _this.$named.appendTo(_this.nmdmgr.element);
          }
          _this.emit("mouseBalloon", ev);
        };
      })(this));
      this.balloon.on("select", (function(_this) {
        return function(ev) {
          console.log(ev);
          return _this.emit("select", ev);
        };
      })(this));
    };

    Named.prototype.destructor = function() {
      this.scopes.forEach(function(scope) {
        return scope.destructor();
      });
      this.scopes = [];
      this.destructors.forEach(function(fn) {
        return fn();
      });
      this.$named.children().remove();
      this.$named.remove();
    };

    Named.prototype.scope = function(scopeId) {
      if (scopeId == null) {
        return this.currentScope;
      }
      if (typeof scopeId !== "number") {
        console.warn("scopeId:", scopeId, "is not a number");
        return this.currentScope;
      }
      if (this.scopes[scopeId] == null) {
        this.scopes[scopeId] = new Scope(scopeId, this.shell, this.balloon, this);
      }
      this.currentScope = this.scopes[scopeId];
      this.$named.append(this.scopes[scopeId].element);
      return this.currentScope;
    };

    Named.prototype.openInputBox = function(id, text) {
      var event;
      if (text == null) {
        text = "";
      }
      event = {
        "type": "userinput",
        "id": id,
        "content": prompt("UserInput", text)
      };
      this.emit("input", event);
    };

    Named.prototype.openCommunicateBox = function(text) {
      var event;
      if (text == null) {
        text = "";
      }
      event = {
        "type": "communicateinput",
        "sender": "user",
        "content": prompt("Communicate", text)
      };
      this.emit("input", event);
    };

    return Named;

  })(EventEmitter2);

  exports.Named = Named;

}).call(this);
